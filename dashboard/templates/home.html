{% extends 'base.html' %} {# Caminho para o base.html, onde está feita a sidebar#}
{% load static %}

{% block title %}Dashboard - Análises e Estatísticas{% endblock %}

{% block content %}
<div class="container-fluid px-4 py-4">

    <!-- Titulo(nome) da Página -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2 class="fw-bold fs-2 mb-0">
            Análises e Estatísticas
        </h2>
        <button class="btn btn-sm btn-outline-primary" id="exportPdfButton">
            <i class="bi bi-file-earmark-arrow-down-fill me-1"></i> Exportar Relatório PDF
        </button>
    </div>

    <!-- Navegação por Abas (Tabs) -->
    <ul class="nav nav-tabs mb-4">
        <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="#">Website</a>
        </li>
        <li class="nav-item">
            <a class="nav-link text-muted" href="#">Eventos</a> {# Placeholder para futura secção de eventos #}
        </li>
    </ul>

    <!-- Cards de tipos de utilizadores (e de views) do gráfico principal-->
    <div class="row g-4 mb-4">
        <!-- Card: Utilizadores Ativos -->
        <div class="col-lg-4 col-md-6">
            <div onclick="showChart('ativos')" class="card border-0 shadow-sm h-100" style="border-radius: 0.75rem; cursor:pointer; transition: box-shadow 0.2s ease;">
                <div class="card-body p-3">
                    <div class="d-flex align-items-center gap-3">
                        <div style="width: 45px; height: 45px; border-radius: 50%; background-color: rgba(13, 110, 253, 0.1); color: #0d6efd; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; flex-shrink: 0;">
                            <i class="bi bi-person-fill"></i>
                        </div>
                        <div>
                            <p class="mb-0 small text-muted">Utilizadores Ativos</p>
                            <h5 class="mb-0 fw-bold" id="total-active-value">{{ total_active }}</h5>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Card: Eventos -->
        <div class="col-lg-4 col-md-6">
             <div onclick="showChart('eventos')" class="card border-0 shadow-sm h-100" style="border-radius: 0.75rem; cursor:pointer; transition: box-shadow 0.2s ease;">
                 <div class="card-body p-3">
                     <div class="d-flex align-items-center gap-3">
                         <div style="width: 45px; height: 45px; border-radius: 50%; background-color: rgba(255, 193, 7, 0.15); color: #ffc107; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; flex-shrink: 0;">
                             <i class="bi bi-calendar-event-fill"></i>
                         </div>
                         <div>
                             <p class="mb-0 small text-muted">Eventos</p>
                             <h5 class="mb-0 fw-bold" id="total-events-value">{{ total_events }}</h5>
                         </div>
                     </div>
                 </div>
            </div>
        </div>
        <!-- Card: Utilizadores Novos -->
        <div class="col-lg-4 col-md-12">
             <div onclick="showChart('novos')" class="card border-0 shadow-sm h-100" style="border-radius: 0.75rem; cursor:pointer; transition: box-shadow 0.2s ease;">
                 <div class="card-body p-3">
                     <div class="d-flex align-items-center gap-3">
                         <div style="width: 45px; height: 45px; border-radius: 50%; background-color: rgba(40, 167, 69, 0.1); color: #28a745; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; flex-shrink: 0;">
                             <i class="bi bi-person-plus-fill"></i>
                         </div>
                         <div>
                             <p class="mb-0 small text-muted">Utilizadores Novos</p>
                             <h5 class="mb-0 fw-bold" id="total-new-value">{{ total_new }}</h5>
                         </div>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <!-- Gráfico Principal de Linhas -->
    <div class="card border-0 shadow-sm" style="border-radius: 0.75rem;">
         <div class="card-header bg-white border-0 pt-3 pb-0 px-3">
             <h5 class="card-title fw-semibold mb-0 fs-6" id="chartTitle">Utilizadores Ativos</h5> {# Título do gráfico, atualizado por JS #}
         </div>
        <div class="card-body chart-container p-2">
            <canvas id="mainLineChart"></canvas>
        </div>
    </div>

    <!-- Dropdown de Seleção de Período (para o gráfico principal e outros cards, apresentados na div anterior) -->
    <div class="dropdown mt-3 mb-4">
      <button class="btn btn-outline-secondary dropdown-toggle btn-sm period-dropdown-button" type="button" id="periodDropdown" data-bs-toggle="dropdown" aria-expanded="false">
        {{ selected_period_label }}
      </button>
      <ul class="dropdown-menu" aria-labelledby="periodDropdown">
        {% for key, period_data in allowed_periods.items %}
          <li>
            <a class="dropdown-item period-link {% if key == selected_period_key %}active{% endif %}"
                href="#"
                data-period-key="{{ key }}">
                {{ period_data.label }}
            </a>
          </li>
        {% endfor %}
      </ul>
    </div>

    <!-- Linha Inferior de Cards de Métricas Detalhadas -->
    <div class="row g-4">
        <!-- Coluna da Esquerda: Visualizações por Título e Tipos de Visitantes -->
        <div class="col-lg-5">
            <!-- Card: Visualizações por Título da Página -->
            <div class="card border-0 shadow-sm mb-4" style="border-radius: 0.75rem;">
                <div class="card-header bg-white border-0 pt-3 pb-0 px-3 d-flex justify-content-between align-items-center">
                    <h5 class="card-title fw-semibold mb-0 fs-6">Visualizações por Título</h5>
                    <div class="dropdown d-inline-block">
                        <button class="btn btn-sm btn-outline-secondary dropdown-toggle period-dropdown-button" type="button" id="pageViewsPeriodDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                            {{ selected_period_label }}
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="pageViewsPeriodDropdown">
                            {% for key, period_data in allowed_periods.items %}
                            <li>
                                <a class="dropdown-item period-link {% if key == selected_period_key %}active{% endif %}"
                                    href="#"
                                    data-period-key="{{ key }}">
                                    {{ period_data.label }}
                                 </a>
                            </li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>
                <div class="card-body">
                    <table class="table table-sm table-borderless small">
                        <thead>
                            <tr class="text-muted">
                                <th>Título</th>
                                <th class="text-end">Visualizações</th>
                            </tr>
                        </thead>
                        <tbody id="page-views-tbody"> {# Conteúdo da tabela atualizado por JS #}
                            {% for page in page_views_data %}
                            <tr>
                                <td title="{{ page.title }}">{{ page.title|truncatechars:45 }}</td>
                                <td class="text-end fw-medium">{{ page.views }}</td>
                            </tr>
                            {% empty %}
                            <tr>
                                <td colspan="2" class="text-center text-muted fst-italic py-3">Nenhum dado de visualização encontrado.</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Card: Novos Visitantes vs. Visitantes Habituais -->
            <div class="card border-0 shadow-sm" style="border-radius: 0.75rem;">
                 <div class="card-header bg-white border-0 pt-3 pb-0 px-3 d-flex justify-content-between align-items-center">
                     <h5 class="card-title fw-semibold mb-0 fs-6">Novos Visitantes vs Visitantes Habituais</h5>
                     <div class="dropdown d-inline-block">
                         <button class="btn btn-sm btn-outline-secondary dropdown-toggle period-dropdown-button" type="button" id="visitorTypePeriodDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                             {{ selected_period_label }}
                         </button>
                         <ul class="dropdown-menu" aria-labelledby="visitorTypePeriodDropdown">
                            {% for key, period_data in allowed_periods.items %}
                              <li>
                                <a class="dropdown-item period-link {% if key == selected_period_key %}active{% endif %}"
                                    href="#"
                                    data-period-key="{{ key }}">
                                    {{ period_data.label }}
                                </a>
                              </li>
                            {% endfor %}
                          </ul>
                     </div>
                 </div>
                 <div class="card-body py-5">
                     <div class= "mt-4 row text-center align-items-center">
                        <!-- Donut: Novos Visitantes -->
                        <div class="col-6" style="height:140px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <canvas id="newVisitorsDonut"
                                    width="120" height="120"
                                    style="max-width: 100%; max-height: 100%;"
                                    data-count="{{ new_visitor_count }}"></canvas> {# Contagem inicial para o JS #}
                            <p class="fw-bold mt-2 mb-0" id="newVisitorsPerc">{{ new_visitor_percentage|default:"--%" }}</p>
                            <small class="text-muted">Novos</small>
                        </div>
                        <!-- Donut: Visitantes Habituais -->
                        <div class="col-6" style="height: 140px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <canvas id="returningVisitorsDonut"
                                    width="120" height="120"
                                    style="max-width: 100%; max-height: 100%;"
                                    data-count="{{ returning_visitor_count }}"></canvas> {# Contagem inicial para o JS #}
                            <p class="fw-bold mt-2 mb-0" id="returningVisitorsPerc">{{ returning_visitor_percentage|default:"--%" }}</p>
                            <small class="text-muted">Habituais</small>
                        </div>
                      </div>
                 </div>
            </div>
        </div>

        <!-- Coluna da Direita: Métricas Adicionais e Mapa -->
        <div class="col-lg-7">
            <div class="row g-4">
                <!-- Card: Média de Páginas Vistas -->
                <div class="col-md-6">
                    <div class="card border-0 shadow-sm h-100" style="border-radius: 0.75rem;">
                        <div class="card-body text-center">
                            <h6 class="card-subtitle mb-2 text-muted" style="font-size: 0.9rem;">Média de páginas vistas</h6>
                            <i class="bi bi-file-earmark-text display-6 text-warning my-2"></i>
                            <h4 class="card-title fw-bold mt-2" id="avg-page-views-value">{{ media_paginas_vistas }}</h4>
                        </div>
                    </div>
                </div>
                <!-- Card: Taxa de Interação -->
                <div class="col-md-6">
                     <div class="card border-0 shadow-sm h-100" style="border-radius: 0.75rem;">
                        <div class="card-body text-center">
                             <h6 class="card-subtitle mb-2 text-muted" style="font-size: 0.9rem;">Taxa de Interação</h6>
                             <i class="bi bi-graph-up display-6 text-success my-2"></i>
                            <h4 class="card-title fw-bold mt-2" id="engagement-rate-value">{{ taxa_interacao }}</h4>
                        </div>
                    </div>
                </div>
                <!-- Card: Utilizadores por País (com Mapa) -->
                <div class="col-12">
                     <div class="card border-0 shadow-sm" style="border-radius: 0.75rem;">
                        <div class="card-header bg-white border-0 pt-3 pb-0 px-3 d-flex justify-content-between align-items-center">
                            <h5 class="card-title fw-semibold mb-0 fs-6">Utilizadores por País</h5>
                            <div class="dropdown d-inline-block">
                                <button class="btn btn-sm btn-outline-secondary dropdown-toggle period-dropdown-button" type="button" id="countryPeriodDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                    {{ selected_period_label }}
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="countryPeriodDropdown">
                                {% for key, period_data in allowed_periods.items %}
                                    <li>
                                        <a class="dropdown-item period-link {% if key == selected_period_key %}active{% endif %}"
                                            href="#"
                                            data-period-key="{{ key }}">
                                            {{ period_data.label }}
                                        </a>
                                    </li>
                                {% endfor %}
                                </ul>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <!-- Mapa Mundial -->
                                <div class="col-md-8">
                                    <div id="worldMapPlaceholder" style="height: 200px; border-radius: 0.5rem; overflow: hidden;">
                                        {# Mapa é renderizado aqui por jsVectorMap #}
                                    </div>
                                </div>
                                <!-- Tabela de Países (Top) -->
                                <div class="col-md-4">
                                    <table class="table table-sm table-borderless small mt-2 mt-md-0">
                                        <thead>
                                            <tr class="text-muted">
                                                <th>País</th>
                                                <th class="text-end">Utilizadores</th>
                                            </tr>
                                        </thead>
                                        <tbody id="country-data-tbody"> {# Conteúdo da tabela atualizado por JS #}
                                            {% for country in country_data|default_if_none:'' %}
                                            <tr>
                                                <td>{{ country.name|default:"--" }}</td>
                                                <td class="text-end fw-medium">{{ country.users | default:"--" }}</td>
                                            </tr>
                                            {% empty %}
                                            <tr>
                                                <td colspan="2" class="text-center text-muted fst-italic py-3">Sem dados.</td>
                                            </tr>
                                            {% endfor %}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{# Scripts de Dados JSON para Carga Inicial no JavaScript #}
{# Estes blocos passam dados do backend Django para o frontend JavaScript #}
{{ labels|json_script:"labels-data" }}
{{ active_users|json_script:"ativos-data" }}
{{ events|json_script:"eventos-data" }}
{{ new_users|json_script:"novos-data" }}
{{ country_data|json_script:"country-data" }}
{{ num_days|json_script:"num-days-initial" }}
{{ selected_period_label|json_script:"selected-period-label-initial" }}

{# Os dados de utilizadores novos e habituais são passados como atributos de dados nos canvas, mas vou deixar aqui porque posso precisar no futuro #}
{# {{ new_visitor_data|json_script:"new-visitor-data" }} #}
{# {{ returning_visitor_data|json_script:"returning-visitor-data" }} #}

{# Inclusão das bibliotecas JavaScript externas #}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script> {# Biblioteca para gráficos, que neste caso serve para os gráficos principais e donut#}
<script src="https://cdn.jsdelivr.net/npm/jsvectormap/dist/js/jsvectormap.min.js"></script> {# Biblioteca para o mapa, usado para renderizar o mapa mundi #}
<script src="https://cdn.jsdelivr.net/npm/jsvectormap/dist/maps/world.js"></script> {# Mapa do mundo, necessário para o jsVectorMap (códigos dos paises, etc) #}

<script>
document.addEventListener('DOMContentLoaded', () => { // Aguarda o carregamento completo do DOM antes de executar o script
    'use strict'; // Ativa o modo estrito para melhor qualidade de código, signifca que todas as variáveis devem ser declaradas antes de serem usadas, ajudando a evitar erros comuns e melhorando a legibilidade do código

    /* ───────────────────────────── ESTADO GLOBAL E REFERÊNCIAS DOM ───────────────────────────── */
    // Dados iniciais para os gráficos, passados pelo Django
    let chartLabelsInitial   = JSON.parse(document.getElementById("labels-data")?.textContent   || '[]'); // Labels para o eixo X do gráfico
    let chartDataAtivosInitial  = JSON.parse(document.getElementById("ativos-data")?.textContent   || '[]'); 
    let chartDataEventosInitial = JSON.parse(document.getElementById("eventos-data")?.textContent  || '[]');
    let chartDataNovosInitial   = JSON.parse(document.getElementById("novos-data")?.textContent    || '[]');
    const initialCountryData = JSON.parse(document.getElementById("country-data")?.textContent || "[]"); // Dados iniciais para o mapa e tabela de países
    
    let currentNumDays = JSON.parse(document.getElementById("num-days-initial")?.textContent || '7'); 
    let currentSelectedPeriodLabel = JSON.parse(document.getElementById("selected-period-label-initial")?.textContent || '"Últimos 7 dias"');

    // Elementos DOM
    const mainLineChartCtx   = document.getElementById("mainLineChart")?.getContext("2d"); // Contexto do canvas do gráfico principal
    const chartTitleEl       = document.getElementById("chartTitle"); 
    const allPeriodButtons   = document.querySelectorAll('.period-dropdown-button'); // Botões de seleção de período (dropdown)
    const newVisitorsDonutEl = document.getElementById('newVisitorsDonut');
    const returningVisitorsDonutEl = document.getElementById('returningVisitorsDonut');

    // Instâncias dos gráficos e mapa
    let mainLineChartInstance = null; 
    let donutNewInstance      = null;
    let donutReturningInstance= null;
    let worldMapInstance      = null;

    let currentChartType = 'ativos'; // Tipo de gráfico principal exibido inicialmente

    /* ───────────────────────────── PLUGIN CHART.JS (TEXTO CENTRALIZADO DENTRO DO GRÁFICO) ───────────────────────────── */
    // Plugin para adicionar texto ao centro de gráficos de Donut
    const centerTextPlugin = {
        id: 'centerText',
        afterDraw(chart, _args, options) {
            if (!options?.text) return; // Ignora se não houver texto definido nas opções do plugin

            const { ctx, chartArea: { width, height } } = chart;
            ctx.save();
            ctx.font         = options.font || '600 14px sans-serif';
            ctx.fillStyle    = options.color || '#212529';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(options.text, width / 2, options.yAdjust ? height / 2 + options.yAdjust : height / 2);
            ctx.restore();
        }
    };
    Chart.register(centerTextPlugin);

    /* ───────────────────────────── FUNÇÕES UTILITÁRIAS UI ───────────────────────────── */
    /**
     * Atualiza o texto de todos os botões de seleção de período.
     * @param {string} text - O novo texto para os botões.
     */
    const setAllPeriodButtonsText = (text) => {
        allPeriodButtons.forEach(btn => btn.textContent = text);
    };

    /**
     * Ativa ou desativa todos os botões de seleção de período.
     * @param {boolean} disabled - True para desativar, false para ativar.
     */
    const toggleAllPeriodButtonsState = (disabled) => {
        allPeriodButtons.forEach(btn => btn.disabled = disabled);
    };

    /* ───────────────────────────── LÓGICA DO GRÁFICO DE LINHA PRINCIPAL ───────────────────────────── */
    /**
     * Atualiza ou cria o gráfico de linha principal.
     * @param {string} type - O tipo de dados a exibir ('ativos', 'eventos', 'novos').
     * @param {string[]} labels - Array de labels para o eixo X.
     * @param {number[]} activeData - Dados de utilizadores ativos.
     * @param {number[]} eventData - Dados de eventos.
     * @param {number[]} newData - Dados de novos utilizadores.
     */
    const updateMainLineChart = (type, labels, activeData, eventData, newData) => {
        if (!mainLineChartCtx) {
            console.warn("Contexto do gráfico principal não encontrado.");
            return;
        }

        const chartStyles = {
            ativos : { label: "Utilizadores Ativos", color: "rgba(13,110,253)" },
            eventos: { label: "Eventos",             color: "rgba(255,193,7)"  },
            novos  : { label: "Utilizadores Novos",  color: "rgba(40,167,69)"  }
        };

        const currentStyle = chartStyles[type];
        if (!currentStyle) {
            console.warn(`Estilo de gráfico desconhecido: ${type}`);
            return;
        }

        const datasetsMap = { // Mapeia os tipos de dados para os datasets correspondentes
            ativos : activeData,
            eventos: eventData,
            novos  : newData
        };
        const currentData = datasetsMap[type] || [];
        const baseColor = currentStyle.color;
        const backgroundColor = baseColor.replace(')', ',0.1)'); // Cor com transparência para preenchimento
        const maxY = Math.max(...currentData, 0) + 2; // Define o máximo do eixo Y com uma margem

        if (mainLineChartInstance) {
            // Atualiza gráfico existente
            mainLineChartInstance.data.labels = labels;
            mainLineChartInstance.data.datasets[0].label = currentStyle.label;
            mainLineChartInstance.data.datasets[0].data = currentData;
            mainLineChartInstance.data.datasets[0].borderColor = baseColor;
            mainLineChartInstance.data.datasets[0].backgroundColor = backgroundColor;
            mainLineChartInstance.data.datasets[0].pointBackgroundColor = baseColor;
            mainLineChartInstance.options.scales.y.suggestedMax = maxY;
            mainLineChartInstance.update();
        } else {
            // Cria novo gráfico
            mainLineChartInstance = new Chart(mainLineChartCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: currentStyle.label,
                        data: currentData,
                        borderColor: baseColor,
                        backgroundColor: backgroundColor,
                        tension: 0.4, // Curvatura da linha
                        fill: true,
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        pointBackgroundColor: baseColor
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false } // Esconde a legenda padrão do Chart.js
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { precision: 0 }, // Garante números inteiros no eixo Y
                            suggestedMax: maxY
                        },
                        x: {
                            grid: { display: false } // Esconde as linhas de grade do eixo X
                        }
                    }
                }
            });
        }
        if (chartTitleEl) chartTitleEl.textContent = currentStyle.label; // Atualiza o título do card do gráfico
    };

    /**
     * Define qual tipo de dados o gráfico principal deve exibir.
     * @param {string} chartType - O tipo de gráfico ('ativos', 'eventos', 'novos').
     */
    window.showChart = (chartType) => { // Exposto globalmente para o `onclick` no HTML
        currentChartType = chartType;
        // Re-renderiza o gráfico com os dados atuais mantidos no estado global (ou os iniciais)
        updateMainLineChart(chartType, chartLabelsInitial, chartDataAtivosInitial, chartDataEventosInitial, chartDataNovosInitial);
    };

    // Observador para redimensionamento do canvas do gráfico principal (útil para renderização inicial correta)
    if (mainLineChartCtx && mainLineChartCtx.canvas) {
        new ResizeObserver(entries => {
            const entry = entries[0];
            if (entry && entry.contentRect.width > 0 && !mainLineChartInstance) { // Renderiza apenas na primeira vez que tem tamanho
                 window.showChart(currentChartType);
            } else if (mainLineChartInstance) {
                // mainLineChartInstance.resize(); // O Chart.js 3+ geralmente lida com resize automaticamente se responsive:true
            }
        }).observe(mainLineChartCtx.canvas);
    } else {
        // Renderização inicial se o ResizeObserver não for necessário ou o canvas não for encontrado imediatamente
         window.showChart(currentChartType);
    }


    /* ───────────────────────────── LÓGICA DOS GRÁFICOS DE DONUT (VISITANTES) ───────────────────────────── */
    /**
     * Renderiza ou atualiza os gráficos de donut para Novos Visitantes e Visitantes Habituais.
     * @param {number} newCount - Contagem de novos visitantes.
     * @param {number} returningCount - Contagem de visitantes habituais.
     */
    const renderVisitorDonuts = (newCount, returningCount) => {
        const totalVisitors = (newCount + returningCount) || 1; // Evita divisão por zero
        const newPercentage = +(newCount / totalVisitors * 100).toFixed(1);
        const returningPercentage = +(returningCount / totalVisitors * 100).toFixed(1); // Poderia ser 100 - newPercentage, mas assim fica bem mais pipi

        // Atualiza os textos das percentagens
        const newVisitorsPercEl = document.getElementById('newVisitorsPerc');
        const returningVisitorsPercEl = document.getElementById('returningVisitorsPerc');
        if (newVisitorsPercEl) newVisitorsPercEl.textContent = `${newPercentage}%`;
        if (returningVisitorsPercEl) returningVisitorsPercEl.textContent = `${returningPercentage}%`;

        const createDonutChart = (canvasElement, mainColor, percentage, textInCenter) => {
            if (!canvasElement) return null;
            const ctx = canvasElement.getContext('2d');
            if (!ctx) return null;

            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, 100 - percentage],
                        backgroundColor: [mainColor, '#e9ecef'], // Cor principal e cor de fundo
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '68%',
                    rotation: -Math.PI / 2, // Começa do topo
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false },
                        centerText: { text: textInCenter || `${percentage}%` } // Usa plugin para texto central
                    }
                }
            });
        };

        // Destrói instâncias anteriores para evitar sobreposição
        donutNewInstance?.destroy();
        donutReturningInstance?.destroy();

        donutNewInstance = createDonutChart(newVisitorsDonutEl, '#70B540', newPercentage, `${newPercentage}%`);
        // Para o gráfico de habituais, invertemos a ordem das cores para um efeito visual específico se desejado,
        // mas aqui manteremos simples. O texto central será a percentagem de habituais.
        donutReturningInstance = createDonutChart(returningVisitorsDonutEl, '#6c757d', returningPercentage, `${returningPercentage}%`);
    };

    // Renderização inicial dos donuts com dados do Django
    if (newVisitorsDonutEl && returningVisitorsDonutEl) {
        renderVisitorDonuts(
            parseInt(newVisitorsDonutEl.dataset.count)  || 0,
            parseInt(returningVisitorsDonutEl.dataset.count) || 0
        );
    }

    /* ───────────────────────────── LÓGICA DO MAPA MUNDIAL (UTILIZADORES POR PAÍS) ───────────────────────────── */
    /**
     * Atualiza a tabela de países e o mapa mundial.
     * @param {Object[]} countryDataArray - Array de objetos, cada um com {name, code, users}.
     */
    const updateCountryDataView = (countryDataArray) => {
        console.log("Mapa: Dados de país recebidos:", JSON.parse(JSON.stringify(countryDataArray)));

        // Atualiza a tabela de países
        const countryTableBody = document.getElementById('country-data-tbody');
        if (countryTableBody) {
            countryTableBody.innerHTML = ''; // Limpa conteúdo anterior
            if (countryDataArray && countryDataArray.length > 0) {
                countryDataArray.forEach(country => {
                    const row = countryTableBody.insertRow();
                    row.insertCell().textContent = country.name || '--';
                    const usersCell = row.insertCell();
                    usersCell.textContent = country.users != null ? country.users : '--';
                    usersCell.className = 'text-end fw-medium';
                });
            } else {
                countryTableBody.innerHTML = '<tr><td colspan="2" class="text-center text-muted fst-italic py-3">Sem dados de país para exibir.</td></tr>';
            }
        }

        // Atualiza o mapa
        const mapaPlaceholder = document.getElementById("worldMapPlaceholder");
        if (mapaPlaceholder) {
            worldMapInstance?.destroy(); // Destrói instância anterior do mapa, se existir
            mapaPlaceholder.innerHTML = ''; // Garante que o placeholder está limpo

            const regionsToColor = {}; // Objeto para mapear códigos de país para um valor (para cor única)
            if (countryDataArray && countryDataArray.length > 0) {
                countryDataArray.forEach(c => {
                    if (c.code && typeof c.code === 'string' && c.users > 0) {
                        regionsToColor[c.code.toUpperCase()] = 1; // Todos os países com dados recebem o valor 1
                    }
                });
            }
            console.log("Mapa: Regiões para colorir:", JSON.parse(JSON.stringify(regionsToColor)));

            const mapConfig = {
                selector: "#worldMapPlaceholder",
                map: "world", // Nome do mapa (world.js deve estar carregado)
                backgroundColor: "transparent",
                zoomOnScroll: false,
                regionStyle: {
                    initial: { fill: '#e9ecef' }, // Cor para países sem dados ou não na série
                    hover: { fill: '#adb5bd' }   // Cor ao fazer hover
                },
                // Callback para personalizar o tooltip ao fazer hover numa região
                // Esta parte do onRegionTipShow não está a funcionar como esperado, mas fica aqui para referência para o futuro
                onRegionTipShow: function (event, tipElement, regionCode) {
                    // Este log é para depurar se o evento de tooltip está a ser acionado
                    console.log(`Mapa: Hover em ${regionCode}`);
                    
                    const country = countryDataArray 
                        ? countryDataArray.find(c => c.code && c.code.toUpperCase() === regionCode.toUpperCase()) 
                        : null;

                    if (country) {
                        tipElement.html(`<strong>${country.name}</strong><br>${country.users} utilizadores`);
                    } else {
                        // Se não encontrar nos nossos dados, tenta obter o nome da biblioteca
                        const mapRegionName = worldMapInstance?.getRegionName(regionCode) || regionCode;
                        tipElement.html(`<strong>${mapRegionName}</strong><br>0 utilizadores`);
                    }
                }
            };

            if (Object.keys(regionsToColor).length > 0) {
                mapConfig.series = {
                    regions: [{
                        values: regionsToColor,
                        scale: { '1': '#0d6efd' }, // Cor azul para todos os países com valor '1', teve de ficar assim, o degradê não estava a funcionar
                        attribute: 'fill'
                    }]
                };
            }
            
            try {
                worldMapInstance = new jsVectorMap(mapConfig);
            } catch (e) {
                console.error("Erro ao criar instância do mapa jsVectorMap:", e);
            }
        }
    };

    // Renderização inicial do mapa e tabela de países
    updateCountryDataView(initialCountryData);


    /* ───────────────────────────── ATUALIZAÇÃO DE DADOS (FETCH API) ───────────────────────────── */
    // Adiciona event listeners a todos os links de seleção de período
    // serve para atualizar os dados do gráfico e outros elementos quando um novo período é selecionado
    document.querySelectorAll('.period-link').forEach(link => {
        link.addEventListener('click', (event) => {
            event.preventDefault();

            const periodKey   = link.dataset.periodKey; // Obtém a chave do período a partir do atributo data-period-key
            const periodLabel = link.textContent.trim(); // Obtém o texto do link (label do período)
            if (!periodKey) return;

            setAllPeriodButtonsText('A carregar…');
            toggleAllPeriodButtonsState(true);

            // Faz a requisição à API para obter novos dados
            fetch(`/api/data/?period=${periodKey}&chart=${currentChartType}`) // currentChartType pode não ser necessário na API se ela sempre retorna todos os dados
                .then(response => {
                    if (!response.ok) {
                        // Tenta ler o erro do JSON, se possível
                        return response.json().then(errData => {
                            throw new Error(errData.error || `Erro HTTP: ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    // Atualiza os dados globais para os gráficos com os novos dados da API
                    chartLabelsInitial   = data.labels       || [];
                    chartDataAtivosInitial  = data.active_users || [];
                    chartDataEventosInitial = data.events       || [];
                    chartDataNovosInitial   = data.new_users    || [];

                    // Atualiza os valores nos cards superiores
                    document.getElementById('total-active-value').textContent  = data.total_active ?? '0';
                    document.getElementById('total-events-value').textContent  = data.total_events ?? '0';
                    document.getElementById('total-new-value').textContent     = data.total_new    ?? '0';

                    // Atualiza os valores nos cards inferiores
                    document.getElementById('avg-page-views-value').textContent = data.media_paginas_vistas ?? '0.00';
                    document.getElementById('engagement-rate-value').textContent = data.taxa_interacao       ?? '0.0%';

                    // Atualiza a tabela de visualizações por título
                    const pageViewsTbody = document.getElementById('page-views-tbody');
                    if (pageViewsTbody) {
                        pageViewsTbody.innerHTML = ''; // Limpa
                        (data.page_views_data || []).forEach(p => {
                            const tr = pageViewsTbody.insertRow();
                            const cellTitle = tr.insertCell();
                            cellTitle.textContent = p.title.length > 45 ? p.title.slice(0,42)+'…' : p.title;
                            cellTitle.title = p.title;
                            const cellViews = tr.insertCell();
                            cellViews.textContent = p.views;
                            cellViews.className = 'text-end fw-medium';
                        });
                        if (!data.page_views_data?.length) {
                            pageViewsTbody.innerHTML = '<tr><td colspan="2" class="text-center text-muted fst-italic py-3">Nenhum dado de visualização encontrado.</td></tr>';
                        }
                    }

                    // Atualiza os donuts de visitantes
                    if (newVisitorsDonutEl && returningVisitorsDonutEl &&
                        typeof data.new_visitor_count !== 'undefined' &&
                        typeof data.returning_visitor_count !== 'undefined') {
                        renderVisitorDonuts(data.new_visitor_count, data.returning_visitor_count);
                    }

                    // Atualiza o mapa e a tabela de países
                    updateCountryDataView(data.country_data || []);
                    
                    // Re-renderiza o gráfico principal com o tipo atual e os novos dados
                    updateMainLineChart(currentChartType, chartLabelsInitial, chartDataAtivosInitial, chartDataEventosInitial, chartDataNovosInitial);

                    // Atualiza a UI dos botões e links de período
                    setAllPeriodButtonsText(periodLabel);
                    document.querySelectorAll('.period-link').forEach(a => {
                         a.classList.toggle('active', a.dataset.periodKey === periodKey);
                    });

                    if (data.num_days !== undefined) { 
                        currentNumDays = data.num_days;
                        console.log("PDF Info: num_days atualizado pela API para:", currentNumDays);
                    }
                    if (data.selected_period_label !== undefined) { 
                        currentSelectedPeriodLabel = data.selected_period_label;
                        console.log("PDF Info: selected_period_label atualizado pela API para:", currentSelectedPeriodLabel);
                    }

                })
                .catch(error => {
                    console.error('Erro ao buscar dados da API:', error);
                    setAllPeriodButtonsText('Erro!');
                    // Opcional: restaurar o texto do botão para o label do período que falhou ou um default
                })
                .finally(() => {
                    toggleAllPeriodButtonsState(false);
                });
        });
    });

    const exportDashboardOrganizadoPdf = () => {
        const { jsPDF } = window.jspdf; // Acede ao construtor jsPDF
        const pdf = new jsPDF({
            orientation: 'p', // portrait
            unit: 'mm',
            format: 'a4'
        });

        const exportButton = document.getElementById('exportPdfButton');
        const originalButtonText = exportButton.innerHTML;
        exportButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> A gerar PDF...';
        exportButton.disabled = true;

        let currentY = 15; // Margem superior inicial em mm
        const pageHeight = pdf.internal.pageSize.getHeight();
        const leftMargin = 15;
        const rightMargin = 15;
        const contentWidth = pdf.internal.pageSize.getWidth() - leftMargin - rightMargin;
        const lineSpacing = 7;
        const sectionSpacing = 10;
        const titleSpacing = 8;

        function checkAndAddPage(alturaEstimadaProximoElemento = 20) {
            if (currentY + alturaEstimadaProximoElemento > pageHeight - 15) { // 15mm de margem inferior
                pdf.addPage();
                currentY = 15; // Reset para margem superior na nova página
            }
        }

        // 1. Título Principal do Relatório
        pdf.setFontSize(20);
        pdf.setTextColor(40, 40, 40); // Cor escura para o título
        pdf.text("Relatório de Análises do Website", pdf.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
        currentY += titleSpacing + 5;

        pdf.setFontSize(11);
        pdf.setTextColor(80, 80, 80); 
        const periodoLabelParaPdf = currentSelectedPeriodLabel || "Período não especificado";
        
        let dateRangeString = "Intervalo de datas não disponível";
        if (typeof currentNumDays === 'number' && currentNumDays > 0) {
            const endDate = new Date(); 
            endDate.setDate(endDate.getDate() - 1); // "Ontem"

            const startDate = new Date(endDate);
            startDate.setDate(endDate.getDate() - (currentNumDays - 1)); 

            const formatDate = (date) => {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0'); // Meses são 0-indexados
                return `${day}/${month}`; 
            };
            dateRangeString = `${formatDate(startDate)} até ${formatDate(endDate)}`;
        }

        pdf.text(`${periodoLabelParaPdf} (${dateRangeString})`, pdf.internal.pageSize.getWidth() / 2, currentY, { align: 'center' });
        currentY += lineSpacing; // Ajusta o espaçamento se necessário

        // Adicionar Data de Geração
        pdf.setFontSize(9);
        pdf.setTextColor(100, 100, 100);
        const generationDate = new Date().toLocaleString('pt-PT');
        pdf.text(`Gerado em: ${generationDate}`, leftMargin, currentY);
        currentY += sectionSpacing;

        // 2. Métricas Principais (Cards)
        checkAndAddPage();
        pdf.setFontSize(14);
        pdf.setTextColor(0, 0, 0); // Resetar cor
        pdf.text("Resumo Geral", leftMargin, currentY);
        pdf.setLineWidth(0.3);
        pdf.line(leftMargin, currentY + 1, leftMargin + contentWidth, currentY + 1); // Linha separadora
        currentY += titleSpacing;
        
        pdf.setFontSize(10);
        const totalActive = document.getElementById('total-active-value')?.textContent || 'N/D';
        const totalEvents = document.getElementById('total-events-value')?.textContent || 'N/D';
        const totalNew = document.getElementById('total-new-value')?.textContent || 'N/D';
        
        pdf.text(`- Utilizadores Ativos Totais: ${totalActive}`, leftMargin, currentY); currentY += lineSpacing;
        pdf.text(`- Eventos Totais: ${totalEvents}`, leftMargin, currentY); currentY += lineSpacing;
        pdf.text(`- Utilizadores Novos Totais: ${totalNew}`, leftMargin, currentY); currentY += sectionSpacing;


        // 3. Gráfico Principal de Linha (como imagem)
        checkAndAddPage(80); // Estimar altura para o gráfico
        pdf.setFontSize(14);
        const chartTitle = document.getElementById('chartTitle')?.textContent || "Tendência de Utilizadores";
        pdf.text(chartTitle, leftMargin, currentY);
        pdf.setLineWidth(0.3);
        pdf.line(leftMargin, currentY + 1, leftMargin + contentWidth, currentY + 1);
        currentY += titleSpacing;

        if (mainLineChartInstance) {
            try {
                const chartImgData = mainLineChartInstance.toBase64Image('image/png', 1.0);
                const chartAspectRatio = mainLineChartInstance.canvas.width / mainLineChartInstance.canvas.height;
                let chartImgWidth = contentWidth; 
                let chartImgHeight = chartImgWidth / chartAspectRatio;
                
                if (chartImgHeight > 70) { // Limitar altura máxima do gráfico no PDF
                    chartImgHeight = 70;
                    chartImgWidth = chartImgHeight * chartAspectRatio;
                }
                checkAndAddPage(chartImgHeight + 5); // Verifica se cabe
                pdf.addImage(chartImgData, 'PNG', leftMargin, currentY, chartImgWidth, chartImgHeight);
                currentY += chartImgHeight + sectionSpacing;
            } catch (e) {
                console.error("Erro ao adicionar gráfico principal ao PDF:", e);
                pdf.setFontSize(10).setTextColor(200,0,0).text("  Erro ao renderizar gráfico.", leftMargin, currentY); currentY += lineSpacing;
                pdf.setTextColor(0,0,0);
            }
        } else {
            pdf.setFontSize(10).text("  Gráfico principal não disponível.", leftMargin, currentY); currentY += lineSpacing;
        }

        // 4. Tabela: Visualizações por Título
        checkAndAddPage(40);
        pdf.setFontSize(14);
        pdf.text("Páginas Mais Vistas", leftMargin, currentY);
        pdf.setLineWidth(0.3);
        pdf.line(leftMargin, currentY + 1, leftMargin + contentWidth, currentY + 1);
        currentY += titleSpacing;

        const pageViewsTableEl = document.getElementById('page-views-tbody');
        if (pageViewsTableEl && typeof pdf.autoTable === 'function') {
            const head = [['Título da Página', 'Visualizações']];
            const body = [];
            pageViewsTableEl.querySelectorAll('tr').forEach(tr => {
                if (tr.cells.length === 2 && !tr.querySelector('.fst-italic')) { // Evitar linha "Nenhum dado"
                    body.push([tr.cells[0].textContent, tr.cells[1].textContent]);
                }
            });
            if (body.length > 0) {
                pdf.autoTable({
                    head: head, body: body, startY: currentY,
                    theme: 'striped', headStyles: { fillColor: [52, 73, 94] }, margin: { left: leftMargin, right: rightMargin },
                });
                currentY = pdf.lastAutoTable.finalY + sectionSpacing;
            } else {
                pdf.setFontSize(10).text("  Nenhum dado de visualizações por título.", leftMargin, currentY); currentY += lineSpacing;
            }
        } else {
            pdf.setFontSize(10).text("  Tabela de visualizações não disponível.", leftMargin, currentY); currentY += lineSpacing;
        }

        // --- Função assíncrona para adicionar elementos que usam html2canvas (como o mapa) ---
        async function addHtmlElementsToPdf() {
            // 5. Mapa de Utilizadores por País (como imagem) e Tabela
            checkAndAddPage(60); // Espaço para o título e a tabela antes do mapa
            pdf.setFontSize(14);
            pdf.text("Distribuição Geográfica de Utilizadores", leftMargin, currentY);
            pdf.setLineWidth(0.3);
            pdf.line(leftMargin, currentY + 1, leftMargin + contentWidth, currentY + 1);
            currentY += titleSpacing;

            const countryTableEl = document.getElementById('country-data-tbody');
            if (countryTableEl && typeof pdf.autoTable === 'function') {
                const countryHead = [['País', 'Utilizadores']];
                const countryBody = [];
                countryTableEl.querySelectorAll('tr').forEach(tr => {
                    if (tr.cells.length === 2 && !tr.querySelector('.fst-italic')) {
                        countryBody.push([tr.cells[0].textContent, tr.cells[1].textContent]);
                    }
                });
                if (countryBody.length > 0) {
                     pdf.autoTable({
                        head: countryHead, body: countryBody, startY: currentY,
                        theme: 'striped', headStyles: { fillColor: [41, 128, 185] }, margin: { left: leftMargin, right: rightMargin },
                        columnStyles: { 
                            0: { cellWidth: 'auto' }, 
                            1: { halign: 'right', cellWidth: 40 } // MODIFICADO: halign: 'right'
                        }
                    });
                    currentY = pdf.lastAutoTable.finalY + 5; // Espaço menor antes do mapa
                } else {
                    pdf.setFontSize(10).text("  Nenhum dado de utilizadores por país.", leftMargin, currentY); currentY += lineSpacing;
                }
            }

            const mapElement = document.getElementById('worldMapPlaceholder');
            if (mapElement) {
                checkAndAddPage(75); // Altura estimada para o mapa
                try {
                    // Ocultar dropdowns sobrepostos ao mapa durante a captura
                    const dropdownsNoMapa = mapElement.closest('.card-body').querySelectorAll('.dropdown');
                    dropdownsNoMapa.forEach(dd => dd.style.visibility = 'hidden');

                    const canvas = await html2canvas(mapElement, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
                    
                    dropdownsNoMapa.forEach(dd => dd.style.visibility = 'visible'); // Restaurar visibilidade

                    const mapImgData = canvas.toDataURL('image/png');
                    const mapAspectRatio = canvas.width / canvas.height;
                    let mapImgWidth = contentWidth * 0.65; // Mapa um pouco menor
                    let mapImgHeight = mapImgWidth / mapAspectRatio;

                    if (mapImgHeight > 65) { // Limitar altura
                        mapImgHeight = 65;
                        mapImgWidth = mapImgHeight * mapAspectRatio;
                    }
                    checkAndAddPage(mapImgHeight + 5);
                    const mapXOffset = (contentWidth - mapImgWidth) / 2 + leftMargin; // Centralizar mapa
                    pdf.addImage(mapImgData, 'PNG', mapXOffset, currentY, mapImgWidth, mapImgHeight);
                    currentY += mapImgHeight + sectionSpacing;
                } catch (err) {
                    console.error("Erro ao renderizar mapa para PDF:", err);
                    pdf.setFontSize(10).setTextColor(200,0,0).text("  Erro ao renderizar mapa.", leftMargin, currentY); currentY += lineSpacing;
                    pdf.setTextColor(0,0,0);
                }
            }
            // Adicionar outras seções aqui se necessário, usando checkAndAddPage()

            // Salva o PDF
            pdf.save(`Relatorio_Dashboard_${new Date().toISOString().slice(0,10)}.pdf`);
        }

        // Chama a função assíncrona e depois restaura o botão
        addHtmlElementsToPdf().finally(() => {
            exportButton.innerHTML = originalButtonText;
            exportButton.disabled = false;
        });
    };

    const exportButton = document.getElementById('exportPdfButton');
    if (exportButton) {
        exportButton.addEventListener('click', exportDashboardOrganizadoPdf);
    }
    // --- FIM DA NOVA FUNCIONALIDADE DE EXPORTAR PDF ---

});
</script>

{% endblock %}